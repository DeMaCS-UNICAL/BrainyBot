%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  make graph not oriented
edge(Y, X, P) :- edge(X, Y, P).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   g&c
swap(ID1, ID2) | notSwap(ID1, ID2) :- node(ID1, _), node(ID2, _), ID1<ID2.
swap(ID2, ID1) :- swap(ID1, ID2).

% exchange node`s edges
exchangedEdge(ID1, ID3, P) :- edge(ID2, ID3, P), swap(ID1, ID2), ID1!=ID3, node(ID1, T), node(ID3, T).
deletedEdge(ID2, ID3) :- edge(ID2, ID3, P), swap(ID1, ID2).

% at least 3 adjacent
atLeast3Adjacent(ID1, ID3, P) :- exchangedEdge(ID1, ID2, P), exchangedEdge(ID1, ID3, P), ID2!=ID3.
atLeast3Adjacent(ID1, ID3, P) :- exchangedEdge(ID1, ID2, P), edge(ID2, ID3, P), ID1!=ID3, node(ID2, T), node(ID3, T), not deletedEdge(ID2, ID3).
atLeast3Adjacent(ID1, ID3, P) :- atLeast3Adjacent(ID1, ID2, P), edge(ID2, ID3, P), ID1!=ID3, node(ID2, T), node(ID3, T), not deletedEdge(ID2, ID3).

% only a single swap
:- #count{ID1, ID2 : swap(ID1, ID2)} != 2.
:- swap(ID1, ID2), not swap(ID2, ID1).

% can t swap between not adjacent nodes
edgeWithoutPosition(ID1,ID2) :- edge(ID1,ID2, _).

:- swap(ID1, ID2), not edgeWithoutPosition(ID1,ID2).

% can t swap between nodes with the same candy type
:- swap(ID1, ID2), node(ID1, T), node(ID2, T).

% at least 3 nodes on the same position
:- #count{ID1, ID3, P : atLeast3Adjacent(ID1, ID3, P)} == 0, not thereIsASwapWithJolly(1).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  adjacent weak
adjacentNodes(ID) :- atLeast3Adjacent(ID, _, _).
adjacentNodes(ID) :- atLeast3Adjacent(_, ID, _).
adjacentNodes(ID) :- exchangedEdge(ID, _).
adjacentNodes(ID) :- exchangedEdge(_, ID).
countAdjacentNodes(C) :- #count{ID : adjacentNodes(ID)} = C.

nodesWithDifferentType(ID) :- node(ID, _), not adjacentNodes(ID).
:~ nodesWithDifferentType(ID). [1@1, ID]



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  bomb weak
:~ swap(ID1, ID2), not bomb(ID1). [1@2, ID1, ID2]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% horizontal weak
% count horizontal nodes
adjacentHorizontal(ID1, ID2, 2) :- horizontal(ID1), edge(ID1, ID2, "horizontal").
adjacentHorizontal(ID1, ID3, COUNT+1) :- adjacentHorizontal(ID1, ID2, COUNT),  edge(ID1, ID3, "horizontal").

% check if it can swap
canSwapWithHorizontal(ID1) :- horizontal(ID1), adjacentHorizontal(ID1, _, COUNT), countAdjacentNodes(C), COUNT > C.
swapWithHorizontal(ID1, ID2) :- canSwapWithHorizontal(ID1), atLeast3Adjacent(ID1, ID2, "horizontal"), % TODO

:~ swap(ID1, ID2), not canSwapWithHorizontal(ID1). [1@3, ID1, ID2]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% vertical weak
% count Vertical nodes
adjacentVertical(ID1, ID2, 2) :- Vertical(ID1), edge(ID1, ID2, "vertical").
adjacentVertical(ID1, ID3, COUNT+1) :- adjacentVertical(ID1, ID2, COUNT),  edge(ID1, ID3, "vertical").

% check if it can swap
canSwapWithVertical(ID1) :- Vertical(ID1), adjacentVertical(ID1, _, COUNT), countAdjacentNodes(C), COUNT > C.


:~ swap(ID1, ID2), not canSwapWithVertical(ID1). [1@3, ID1, ID2]



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  jolly weak
jollyCount(ID1, T, C) :- #count{IDX : node(IDX, T)} = C, node(ID1, "jolly"), edge(ID1, ID2, _), node(ID2, T). % count nodes for each jolly, max relative
maxCountForJolly(K) :- #max{C, ID, T : jollyCount(ID, T, C)} = K. % max absolute
maxJolly(ID, T) :- maxCountForJolly(K), jollyCount(ID, T, K). % find max jolly
swapWithJolly(ID1, ID2) :- maxJolly(ID1, T), edge(ID1, ID2, _), node(ID2, T), maxCountForJolly(K), countAdjacentNodes(C), K > C. % choose swap with jolly
thereIsASwapWithJolly(1) :- swapWithJolly(ID1, ID2).

:~ swapWithJolly(ID1, ID2), not swap(ID1, ID2). [1@4, ID1, ID2] % if exists a swap can match so much candy
























# by Mario Avolio