#show swap/2.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  make graph not oriented
edge(Y, X, P) :- edge(X, Y, P).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   g&c
swap(ID1, ID2) | notSwap(ID1, ID2) :- node(ID1, _), node(ID2, _), ID1<ID2.
swap(ID2, ID1) :- swap(ID1, ID2).
swappedNodes(ID) :- swap(ID, _).

% exchange node`s edges
exchangedEdge(ID1, ID3, P) :- edge(ID2, ID3, P), swap(ID1, ID2), ID1!=ID3, node(ID1, T), node(ID3, T).
deletedEdge(ID2, ID3) :- edge(ID2, ID3, P), swap(ID1, ID2).

% at least 3 adjacent
atLeast3Adjacent(ID1, ID3, P) :- exchangedEdge(ID1, ID2, P), exchangedEdge(ID1, ID3, P), ID2!=ID3.
atLeast3Adjacent(ID1, ID3, P) :- exchangedEdge(ID1, ID2, P), edge(ID2, ID3, P), ID1!=ID3, node(ID2, T), node(ID3, T), not deletedEdge(ID2, ID3).
atLeast3Adjacent(ID1, ID3, P) :- atLeast3Adjacent(ID1, ID2, P), edge(ID2, ID3, P), ID1!=ID3, node(ID2, T), node(ID3, T), not deletedEdge(ID2, ID3).

% only a single swap
:- #count{ID1, ID2 : swap(ID1, ID2)} != 2.
:- swap(ID1, ID2), not swap(ID2, ID1).

% can t swap between not adjacent nodes
edgeWithoutPosition(ID1,ID2) :- edge(ID1,ID2, _).

:- swap(ID1, ID2), not edgeWithoutPosition(ID1,ID2).

% can t swap between nodes with the same candy type
:- swap(ID1, ID2), node(ID1, T), node(ID2, T).

% at least 3 nodes on the same position
:- #count{ID1, ID3, P : atLeast3Adjacent(ID1, ID3, P)} == 0, not thereIsASwapWithJolly(1).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  adjacent weak
adjacentNodes(ID) :- atLeast3Adjacent(ID, _, _).
adjacentNodes(ID) :- atLeast3Adjacent(_, ID, _).
adjacentNodes(ID) :- exchangedEdge(ID, _).
adjacentNodes(ID) :- exchangedEdge(_, ID).
countAdjacentNodes(C) :- #count{ID : adjacentNodes(ID)} = C.

nodesWithDifferentType(ID) :- node(ID, _), not adjacentNodes(ID).
:~ nodesWithDifferentType(ID). [1@1, ID]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  adjacent weak
adjacentNodes(ID) :- atLeast3Adjacent(ID, _, _).
adjacentNodes(ID) :- atLeast3Adjacent(_, ID, _).
adjacentNodes(ID) :- exchangedEdge(ID, _).
adjacentNodes(ID) :- exchangedEdge(_, ID).
countAdjacentNodes(C) :- #count{ID : adjacentNodes(ID)} = C.

nodesWithDifferentType(ID) :- node(ID, _), not adjacentNodes(ID).
:~ nodesWithDifferentType(ID). [1@1, ID]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  bomb weak
:~ bomb(ID), not adjacentNodes(ID). [1@2, ID]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% horizontal weak
:~ horizontal(ID), not adjacentNodes(ID). [1@3, ID]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% vertical weak
:~ vertical(ID), not adjacentNodes(ID). [1@3, ID]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  jolly weak
jollyCount(ID1, T, C) :- #count{IDX : node(IDX, T)} = C, node(ID1, "jolly"), edge(ID1, ID2, _), node(ID2, T). % count nodes for each jolly, max relative
maxCountForJolly(K) :- #max{C, ID, T : jollyCount(ID, T, C)} = K. % max absolute
maxJolly(ID, T) :- maxCountForJolly(K), jollyCount(ID, T, K). % find max jolly
swapWithJolly(ID1, ID2) :- maxJolly(ID1, T), edge(ID1, ID2, _), node(ID2, T), maxCountForJolly(K), countAdjacentNodes(C), K > C. % choose swap with jolly
thereIsASwapWithJolly(1) :- swapWithJolly(ID1, ID2).

:~ swapWithJolly(ID1, ID2), not swap(ID1, ID2). [1@4, ID1, ID2] % if exists a swap can match so much candy



